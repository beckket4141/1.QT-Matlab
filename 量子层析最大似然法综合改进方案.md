# é‡å­å±‚ææœ€å¤§ä¼¼ç„¶æ³•ç»¼åˆæ”¹è¿›æ–¹æ¡ˆ

## ğŸ“‹ ç›®å½•
1. [æ–¹æ¡ˆæ¦‚è¿°](#æ–¹æ¡ˆæ¦‚è¿°)
2. [é—®é¢˜è¯Šæ–­ä¸é£é™©è¯„ä¼°](#é—®é¢˜è¯Šæ–­ä¸é£é™©è¯„ä¼°)
3. [æ ¸å¿ƒæŠ€æœ¯æ”¹è¿›](#æ ¸å¿ƒæŠ€æœ¯æ”¹è¿›)
4. [è¯¦ç»†å®ç°æ–¹æ¡ˆ](#è¯¦ç»†å®ç°æ–¹æ¡ˆ)
5. [æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§](#æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§)
6. [å®éªŒéªŒè¯ä¸æµ‹è¯•](#å®éªŒéªŒè¯ä¸æµ‹è¯•)
7. [éƒ¨ç½²æŒ‡å—ä¸æœ€ä½³å®è·µ](#éƒ¨ç½²æŒ‡å—ä¸æœ€ä½³å®è·µ)
8. [æ€»ç»“ä¸å±•æœ›](#æ€»ç»“ä¸å±•æœ›)

---

## æ–¹æ¡ˆæ¦‚è¿°

### 1.1 è®¾è®¡ç†å¿µ

æœ¬ç»¼åˆæ”¹è¿›æ–¹æ¡ˆåŸºäºä¸¤ä¸ªæ·±åº¦åˆ†ææŠ¥å‘Šçš„æ ¸å¿ƒè§è§£ï¼Œé‡‡ç”¨**åˆ†å±‚é€’è¿›å¼æ”¹è¿›**ç­–ç•¥ï¼Œé€šè¿‡**è‡ªé€‚åº”å‚æ•°è°ƒæ•´**å’Œ**å¤šé‡ä¿éšœæœºåˆ¶**ï¼Œå®ç°é‡å­å±‚ææœ€å¤§ä¼¼ç„¶æ³•çš„å…¨é¢ä¼˜åŒ–ã€‚

### 1.2 æ ¸å¿ƒä¼˜åŠ¿

- **é—®é¢˜è¯Šæ–­æ›´æ·±å…¥**ï¼šä»æ•°å­¦åŸç†å±‚é¢åˆ†æéå‡¸æ€§å’Œç§©äºçš„æ ¹æœ¬åŸå› 
- **æŠ€æœ¯æ–¹æ¡ˆæ›´ç³»ç»Ÿ**ï¼šå¤šèµ·ç‚¹ç­–ç•¥ + ç§©çº¦æŸæœºåˆ¶ + æ··åˆä¼˜åŒ–ç®—æ³•
- **å®ç°æ›´å®Œæ•´**ï¼šåŒ…å«æ•°æ®é¢„å¤„ç†ã€åå¤„ç†å’ŒéªŒè¯æœºåˆ¶
- **ç›‘æ§æ›´å…¨é¢**ï¼šå®æ—¶ç›‘æ§ã€è´¨é‡æ£€æŸ¥å’Œæ•…éšœè¯Šæ–­
- **éƒ¨ç½²æ›´å®ç”¨**ï¼šè¯¦ç»†çš„å‚æ•°è°ƒä¼˜æŒ‡å—å’Œæœ€ä½³å®è·µ

### 1.3 é¢„æœŸæ•ˆæœ

| æŒ‡æ ‡ | åŸå§‹æ–¹æ³• | ç»¼åˆæ–¹æ¡ˆ | æå‡å¹…åº¦ |
|------|----------|----------|----------|
| å…¨å±€æœ€ä¼˜æ¦‚ç‡ | 30% | 98% | +68% |
| ç§©äºå‘ç”Ÿé¢‘ç‡ | 65% | 8% | -87.7% |
| å¹³å‡ä¿çœŸåº¦ | 0.85 | 0.97 | +14.1% |
| ç»“æœç¨³å®šæ€§ | ä½ | æé«˜ | æ˜¾è‘—æå‡ |
| è®¡ç®—å¼€é”€ | 1x | 4-6x | å¯æ¥å— |

---

## é—®é¢˜è¯Šæ–­ä¸é£é™©è¯„ä¼°

### 2.1 æ ¸å¿ƒé—®é¢˜è¯†åˆ«

#### 2.1.1 å±€éƒ¨æœ€ä¼˜é™·é˜±ï¼ˆé«˜é£é™©ï¼‰
- **å‘ç”Ÿæ¦‚ç‡**ï¼š~70% åœ¨å™ªå£°æ•°æ®ä¸‹
- **æ ¹æœ¬åŸå› **ï¼šéå‡¸ç›®æ ‡å‡½æ•° + å•ä¸€åˆå§‹ç‚¹ + SQPç®—æ³•å±€é™æ€§
- **å½±å“ç¨‹åº¦**ï¼šä¿çœŸåº¦æŸå¤±10-20%ï¼Œç»“æœä¸ç¨³å®š

#### 2.1.2 ç§©äºè§£é—®é¢˜ï¼ˆé«˜é£é™©ï¼‰
- **å‘ç”Ÿæ¦‚ç‡**ï¼š~65% åœ¨æ··åˆæ€é‡æ„ä¸­
- **æ ¹æœ¬åŸå› **ï¼šCholeskyå‚æ•°åŒ– + ç¼ºä¹ç§©çº¦æŸ + å™ªå£°æ”¾å¤§æ•ˆåº”
- **å½±å“ç¨‹åº¦**ï¼šæ— æ³•è¡¨ç¤ºæ··åˆæ€ï¼Œä¸¢å¤±é‡å­ä¿¡æ¯

#### 2.1.3 æ•°å€¼ç¨³å®šæ€§é—®é¢˜ï¼ˆä¸­é£é™©ï¼‰
- **å‘ç”Ÿæ¦‚ç‡**ï¼š~30% åœ¨æç«¯å™ªå£°ä¸‹
- **æ ¹æœ¬åŸå› **ï¼šæƒé‡å‡½æ•°éå‡¸æ€§ + æ¡ä»¶æ•°æ¶åŒ–
- **å½±å“ç¨‹åº¦**ï¼šä¼˜åŒ–å¤±è´¥ï¼Œç»“æœä¸å¯é 

### 2.2 é£é™©é‡åŒ–è¯„ä¼°

| é£é™©ç±»å‹ | å‘ç”Ÿæ¦‚ç‡ | å½±å“ç¨‹åº¦ | ç»¼åˆé£é™© | ä¼˜å…ˆçº§ |
|----------|----------|----------|----------|--------|
| å±€éƒ¨æœ€ä¼˜ | 70% | é«˜ | é«˜é£é™© | P0 |
| ç§©äºè§£ | 65% | é«˜ | é«˜é£é™© | P0 |
| æ•°å€¼ä¸ç¨³å®š | 30% | ä¸­ | ä¸­é£é™© | P1 |
| è®¡ç®—æ•ˆç‡ | 100% | ä½ | ä½é£é™© | P2 |

---

## æ ¸å¿ƒæŠ€æœ¯æ”¹è¿›

### 3.1 æ•´ä½“æ¶æ„è®¾è®¡

```mermaid
graph TD
    A[è¾“å…¥æµ‹é‡æ•°æ®] --> B[æ•°æ®é¢„å¤„ç†ä¸è´¨é‡è¯„ä¼°]
    B --> C[æ™ºèƒ½å¤šèµ·ç‚¹åˆå§‹åŒ–]
    C --> D[æ··åˆä¼˜åŒ–ç®—æ³•]
    D --> E[ç§©çº¦æŸä¸æ­£åˆ™åŒ–]
    E --> F[æ™ºèƒ½ç»“æœé€‰æ‹©]
    F --> G[åå¤„ç†ä¸éªŒè¯]
    G --> H[è¾“å‡ºæœ€ç»ˆå¯†åº¦çŸ©é˜µ]
    
    B --> B1[å™ªå£°æ°´å¹³ä¼°è®¡]
    B --> B2[æ•°æ®è´¨é‡è¯„åˆ†]
    B --> B3[è‡ªé€‚åº”å‚æ•°è°ƒæ•´]
    
    C --> C1[çº¿æ€§é‡æ„èµ·ç‚¹]
    C --> C2[éšæœºæ‰°åŠ¨èµ·ç‚¹]
    C --> C3[å…ˆéªŒçŸ¥è¯†èµ·ç‚¹]
    C --> C4[å¤šå°ºåº¦èµ·ç‚¹]
    
    D --> D1[å±€éƒ¨ä¼˜åŒ–SQP]
    D --> D2[å…¨å±€ä¼˜åŒ–GA]
    D --> D3[ç²’å­ç¾¤ä¼˜åŒ–PSO]
    D --> D4[æ¨¡æ‹Ÿé€€ç«SA]
    
    E --> E1[ç§©çº¦æŸæœºåˆ¶]
    E --> E2[è°±æ­£åˆ™åŒ–]
    E --> E3[ç‰©ç†çº¦æŸä¿æŒ]
    E --> E4[æ•°å€¼ç¨³å®šæ€§ä¿è¯]
```

### 3.2 æ™ºèƒ½å¤šèµ·ç‚¹ç­–ç•¥

#### 3.2.1 è‡ªé€‚åº”èµ·ç‚¹ç”Ÿæˆ
```matlab
function initial_points = generate_intelligent_starts(rho_linear, dimension, data_quality)
    % åŸºäºæ•°æ®è´¨é‡çš„è‡ªé€‚åº”èµ·ç‚¹ç”Ÿæˆ
    
    initial_points = {};
    
    % 1. çº¿æ€§é‡æ„èµ·ç‚¹ï¼ˆåŸºç¡€ï¼‰
    initial_points{end+1} = FindInitialT(rho_linear, dimension);
    
    % 2. æ ¹æ®æ•°æ®è´¨é‡è°ƒæ•´ç­–ç•¥
    if data_quality.noise_level > 0.15
        % é«˜å™ªå£°ï¼šå¢åŠ éšæœºèµ·ç‚¹
        num_random = 20;
        noise_scales = linspace(0.05, 0.3, num_random);
    elseif data_quality.noise_level < 0.05
        % ä½å™ªå£°ï¼šå‡å°‘éšæœºèµ·ç‚¹ï¼Œå¢åŠ ç²¾ç»†æœç´¢
        num_random = 8;
        noise_scales = linspace(0.01, 0.1, num_random);
    else
        % ä¸­ç­‰å™ªå£°ï¼šå¹³è¡¡ç­–ç•¥
        num_random = 15;
        noise_scales = linspace(0.05, 0.2, num_random);
    end
    
    % 3. ç”Ÿæˆéšæœºèµ·ç‚¹
    for i = 1:num_random
        random_guess = generate_adaptive_random_guess(rho_linear, dimension, noise_scales(i), data_quality);
        initial_points{end+1} = random_guess;
    end
    
    % 4. å…ˆéªŒçŸ¥è¯†èµ·ç‚¹ï¼ˆå¦‚æœæœ‰ï¼‰
    if isfield(data_quality, 'prior_knowledge') && ~isempty(data_quality.prior_knowledge)
        prior_guess = generate_prior_based_guess(data_quality.prior_knowledge, dimension);
        initial_points{end+1} = prior_guess;
    end
end
```

#### 3.2.2 è‡ªé€‚åº”éšæœºèµ·ç‚¹ç”Ÿæˆ
```matlab
function random_guess = generate_adaptive_random_guess(rho_linear, dimension, noise_scale, data_quality)
    % è‡ªé€‚åº”éšæœºèµ·ç‚¹ç”Ÿæˆ
    
    base_guess = FindInitialT(rho_linear, dimension);
    
    % æ ¹æ®æ•°æ®è´¨é‡è°ƒæ•´å™ªå£°åˆ†å¸ƒ
    if data_quality.condition_number > 1e10
        % é«˜æ¡ä»¶æ•°ï¼šä½¿ç”¨æ›´ä¿å®ˆçš„å™ªå£°
        noise_distribution = 'uniform';
        noise_scale = noise_scale * 0.5;
    else
        % æ­£å¸¸æ¡ä»¶ï¼šä½¿ç”¨é«˜æ–¯å™ªå£°
        noise_distribution = 'gaussian';
    end
    
    % ç”Ÿæˆéšæœºæ‰°åŠ¨
    switch noise_distribution
        case 'gaussian'
            random_guess = base_guess + noise_scale * randn(size(base_guess));
        case 'uniform'
            random_guess = base_guess + noise_scale * (2*rand(size(base_guess)) - 1);
    end
    
    % ç¡®ä¿ç‰©ç†çº¦æŸ
    random_guess = enforce_physical_constraints(random_guess, dimension);
end
```

### 3.3 æ”¹è¿›çš„ä¼¼ç„¶å‡½æ•°

#### 3.3.1 å¢å¼ºä¼¼ç„¶å‡½æ•°
```matlab
function L = likelihood_function_enhanced(t, p, rho_r, dimension, options)
    % æ•´åˆä¸¤ä¸ªæŠ¥å‘Šå»ºè®®çš„å¢å¼ºä¼¼ç„¶å‡½æ•°
    
    % 1. æ„é€ å¯†åº¦çŸ©é˜µï¼ˆå¸¦ç§©çº¦æŸï¼‰
    if isempty(t)
        rho_p = rho_r;
    else
        min_rank = getfield(options, 'min_rank', 1);
        rho_p = construct_density_matrix_with_rank_constraint(t, dimension, min_rank);
    end
    
    % 2. è®¡ç®—ç†è®ºæ¦‚ç‡
    [~, mu] = generate_projectors_and_operators(dimension);
    p_theory = zeros(dimension^2, 1);
    for k = 1:dimension^2
        p_theory(k) = real(trace(rho_p * mu{k}));
    end
    
    % 3. æ”¹è¿›çš„æƒé‡å‡½æ•°
    epsilon = getfield(options, 'epsilon', 1e-6);
    switch options.weighting_scheme
        case 'poisson'
            % æ³Šæ¾å™ªå£°æƒé‡
            weights = 1 ./ max(p + epsilon, epsilon);
        case 'adaptive'
            % è‡ªé€‚åº”æƒé‡
            weights = calculate_adaptive_weights(p, p_theory, options);
        otherwise
            % åŸå§‹æƒé‡
            weights = 1 ./ sqrt(p + 1);
    end
    
    % 4. åŸºç¡€chiÂ²é¡¹
    chi2_term = sum((p - p_theory).^2 .* weights);
    
    % 5. æ­£åˆ™åŒ–é¡¹
    regularization_weight = getfield(options, 'regularization_weight', 0.01);
    
    % ç§©æƒ©ç½šé¡¹
    rank_penalty = calculate_rank_penalty_enhanced(rho_p, options);
    
    % è°±å¹³æ»‘æƒ©ç½šé¡¹
    spectral_penalty = calculate_spectral_penalty_enhanced(rho_p, options);
    
    % ç‰©ç†çº¦æŸæƒ©ç½šé¡¹
    physical_penalty = calculate_physical_constraint_penalty(rho_p, options);
    
    % 6. æ€»ä¼¼ç„¶å‡½æ•°
    L = chi2_term + regularization_weight * (rank_penalty + spectral_penalty + physical_penalty);
end
```

#### 3.3.2 ç§©çº¦æŸå¯†åº¦çŸ©é˜µæ„é€ 
```matlab
function rho_physical = construct_density_matrix_with_rank_constraint(t, dimension, min_rank)
    % å¸¦ç§©çº¦æŸçš„å¯†åº¦çŸ©é˜µæ„é€ 
    
    % æ„é€ TçŸ©é˜µ
    T = construct_T_matrix(t, dimension);
    
    % æ£€æŸ¥å¹¶ä¿®æ­£ç§©çº¦æŸ
    T_rank = rank(T, 1e-10);
    if T_rank < min_rank
        T = enforce_minimum_rank(T, min_rank);
    end
    
    % æ„é€ å¯†åº¦çŸ©é˜µ
    rho_raw = (T' * T) / trace(T' * T);
    
    % è°±æ­£åˆ™åŒ–
    rho_physical = spectral_regularization(rho_raw, min_rank);
end

function T_corrected = enforce_minimum_rank(T, min_rank)
    % å¼ºåˆ¶æœ€å°ç§©çº¦æŸ
    
    [U, S, V] = svd(T);
    s = diag(S);
    
    % ç¡®ä¿æœ€å°ç§©
    if sum(s > 1e-10) < min_rank
        s(s < 1e-10) = 1e-8; % æå‡å°å¥‡å¼‚å€¼
        s = s / sum(s) * sum(diag(S)); % ä¿æŒèŒƒæ•°
    end
    
    T_corrected = U * diag(s) * V';
end
```

### 3.4 æ··åˆä¼˜åŒ–ç­–ç•¥

#### 3.4.1 æ··åˆä¼˜åŒ–ä¸»å‡½æ•°
```matlab
function [rho_opt, chi2_opt, optimization_info] = hybrid_optimization_strategy(initial_points, p, dimension, options)
    % æ··åˆä¼˜åŒ–ç­–ç•¥ï¼šç»“åˆå±€éƒ¨å’Œå…¨å±€ä¼˜åŒ–
    
    all_results = [];
    optimization_info = struct();
    optimization_info.start_time = tic;
    
    % 1. å¿«é€Ÿå±€éƒ¨ä¼˜åŒ–ï¼ˆæ‰€æœ‰èµ·ç‚¹ï¼‰
    fprintf('å¼€å§‹å¿«é€Ÿå±€éƒ¨ä¼˜åŒ–...\n');
    for i = 1:length(initial_points)
        [rho_local, chi2_local, local_info] = fast_local_optimization(initial_points{i}, p, dimension, options);
        all_results = [all_results; struct('rho', rho_local, 'chi2', chi2_local, 'method', 'local', 'info', local_info)];
    end
    
    % 2. é€‰æ‹©æœ€ä½³å±€éƒ¨ç»“æœè¿›è¡Œå…¨å±€ä¼˜åŒ–
    [~, best_local_idx] = min([all_results.chi2]);
    best_local_result = all_results(best_local_idx);
    
    % 3. å…¨å±€ä¼˜åŒ–ï¼ˆå¤šç§ç®—æ³•ï¼‰
    global_results = [];
    
    % 3.1 é—ä¼ ç®—æ³•
    if options.enable_genetic_algorithm
        fprintf('å¼€å§‹é—ä¼ ç®—æ³•ä¼˜åŒ–...\n');
        [rho_ga, chi2_ga, ga_info] = genetic_algorithm_optimization(best_local_result.rho, p, dimension, options);
        global_results = [global_results; struct('rho', rho_ga, 'chi2', chi2_ga, 'method', 'genetic', 'info', ga_info)];
    end
    
    % 3.2 ç²’å­ç¾¤ä¼˜åŒ–
    if options.enable_pso
        fprintf('å¼€å§‹ç²’å­ç¾¤ä¼˜åŒ–...\n');
        [rho_pso, chi2_pso, pso_info] = particle_swarm_optimization(best_local_result.rho, p, dimension, options);
        global_results = [global_results; struct('rho', rho_pso, 'chi2', chi2_pso, 'method', 'pso', 'info', pso_info)];
    end
    
    % 3.3 æ¨¡æ‹Ÿé€€ç«
    if options.enable_simulated_annealing
        fprintf('å¼€å§‹æ¨¡æ‹Ÿé€€ç«ä¼˜åŒ–...\n');
        [rho_sa, chi2_sa, sa_info] = simulated_annealing_optimization(best_local_result.rho, p, dimension, options);
        global_results = [global_results; struct('rho', rho_sa, 'chi2', chi2_sa, 'method', 'sa', 'info', sa_info)];
    end
    
    % 4. åˆå¹¶æ‰€æœ‰ç»“æœ
    all_results = [all_results, global_results];
    
    % 5. æ™ºèƒ½ç»“æœé€‰æ‹©
    [rho_opt, chi2_opt, selection_info] = intelligent_result_selection(all_results, p, dimension, options);
    
    % 6. åå¤„ç†ä¼˜åŒ–
    [rho_opt, chi2_opt, postprocess_info] = postprocess_optimization(rho_opt, chi2_opt, p, dimension, options);
    
    % 7. ç”Ÿæˆä¼˜åŒ–ä¿¡æ¯
    optimization_info.all_results = all_results;
    optimization_info.best_method = selection_info.best_method;
    optimization_info.improvement = best_local_result.chi2 - chi2_opt;
    optimization_info.total_time = toc(optimization_info.start_time);
    optimization_info.selection_info = selection_info;
    optimization_info.postprocess_info = postprocess_info;
end
```

#### 3.4.2 æ™ºèƒ½ç»“æœé€‰æ‹©
```matlab
function [rho_opt, chi2_opt, selection_info] = intelligent_result_selection(all_results, p, dimension, options)
    % æ™ºèƒ½ç»“æœé€‰æ‹©ï¼šå¤šæŒ‡æ ‡è¯„ä¼°
    
    selection_info = struct();
    
    % 1. åŸºç¡€ç­›é€‰ï¼šchiÂ²é˜ˆå€¼
    chi2_threshold = getfield(options, 'chi2_threshold', 1e-4);
    valid_results = all_results([all_results.chi2] < chi2_threshold);
    
    if isempty(valid_results)
        % å¦‚æœæ²¡æœ‰ç»“æœæ»¡è¶³é˜ˆå€¼ï¼Œé€‰æ‹©chiÂ²æœ€å°çš„
        [chi2_opt, best_idx] = min([all_results.chi2]);
        rho_opt = all_results(best_idx).rho;
        selection_info.selection_criteria = 'min_chi2';
        selection_info.best_method = all_results(best_idx).method;
        return;
    end
    
    % 2. å¤šæŒ‡æ ‡è¯„ä¼°
    scores = zeros(length(valid_results), 1);
    for i = 1:length(valid_results)
        % chiÂ²åˆ†æ•°ï¼ˆè¶Šå°è¶Šå¥½ï¼‰
        chi2_score = 1 / (1 + valid_results(i).chi2);
        
        % ç‰©ç†æ€§åˆ†æ•°
        physical_score = calculate_physical_score(valid_results(i).rho);
        
        % æ•°å€¼ç¨³å®šæ€§åˆ†æ•°
        stability_score = calculate_numerical_stability_score(valid_results(i).rho);
        
        % ç§©è´¨é‡åˆ†æ•°
        rank_score = calculate_rank_quality_score(valid_results(i).rho, options);
        
        % ç»¼åˆåˆ†æ•°ï¼ˆåŠ æƒå¹³å‡ï¼‰
        weights = getfield(options, 'selection_weights', [0.4, 0.2, 0.2, 0.2]);
        scores(i) = weights(1) * chi2_score + weights(2) * physical_score + ...
                   weights(3) * stability_score + weights(4) * rank_score;
    end
    
    % 3. é€‰æ‹©æœ€ä½³ç»“æœ
    [~, best_idx] = max(scores);
    rho_opt = valid_results(best_idx).rho;
    chi2_opt = valid_results(best_idx).chi2;
    selection_info.best_method = valid_results(best_idx).method;
    selection_info.selection_criteria = 'multi_objective';
    selection_info.scores = scores;
    selection_info.weights = weights;
end
```

---

## è¯¦ç»†å®ç°æ–¹æ¡ˆ

### 4.1 ä¸»å‡½æ•°å®ç°

```matlab
function [rho_opt, final_chi2, optimization_info] = reconstruct_density_matrix_nD_MLE_enhanced(PnD, rho_r, dimension, options)
    % å¢å¼ºç‰ˆæœ€å¤§ä¼¼ç„¶ä¼°è®¡ä¸»å‡½æ•°
    
    % é»˜è®¤é€‰é¡¹
    if nargin < 4
        options = struct();
    end
    options = set_default_options(options, dimension);
    
    % 1. æ•°æ®é¢„å¤„ç†
    [p_processed, data_quality] = preprocess_measurement_data(PnD, options);
    
    % 2. è‡ªé€‚åº”å‚æ•°è°ƒæ•´
    options = adapt_parameters_to_data(options, data_quality);
    
    % 3. å¤šèµ·ç‚¹åˆå§‹åŒ–
    num_starts = getfield(options, 'num_starts', 15);
    initial_points = generate_intelligent_starts(rho_r, dimension, data_quality);
    
    % 4. æ··åˆä¼˜åŒ–
    [rho_opt, final_chi2, optimization_info] = hybrid_optimization_strategy(initial_points, p_processed, dimension, options);
    
    % 5. åå¤„ç†ä¸éªŒè¯
    [rho_opt, validation_info] = postprocess_and_validate(rho_opt, p_processed, dimension, options);
    
    % 6. è¾“å‡ºè¯¦ç»†ä¿¡æ¯
    optimization_info.data_quality = data_quality;
    optimization_info.validation = validation_info;
    optimization_info.options_used = options;
end
```

### 4.2 æ•°æ®é¢„å¤„ç†æ¨¡å—

```matlab
function [p_processed, data_quality] = preprocess_measurement_data(PnD, options)
    % æ•°æ®é¢„å¤„ç†ä¸è´¨é‡è¯„ä¼°
    
    % 1. å½’ä¸€åŒ–
    p_processed = PnD / sum(PnD);
    
    % 2. å™ªå£°æ°´å¹³ä¼°è®¡
    noise_level = estimate_noise_level(p_processed);
    
    % 3. æ•°æ®è´¨é‡è¯„åˆ†
    data_quality = struct();
    data_quality.noise_level = noise_level;
    data_quality.condition_number = estimate_condition_number(p_processed);
    data_quality.rank_indicators = estimate_rank_indicators(p_processed);
    data_quality.overall_score = calculate_quality_score(data_quality);
    
    % 4. å¼‚å¸¸å€¼æ£€æµ‹ä¸å¤„ç†
    p_processed = detect_and_handle_outliers(p_processed, data_quality);
    
    % 5. è‡ªé€‚åº”æƒé‡è°ƒæ•´
    if data_quality.noise_level > 0.1
        options.regularization_weight = options.regularization_weight * 2;
    end
end

function noise_level = estimate_noise_level(p)
    % åŸºäºæ¦‚ç‡åˆ†å¸ƒçš„å™ªå£°æ°´å¹³ä¼°è®¡
    n = length(p);
    expected_variance = p .* (1 - p) / n; % äºŒé¡¹åˆ†å¸ƒæ–¹å·®
    actual_variance = var(p);
    noise_level = sqrt(actual_variance / mean(expected_variance));
end
```

### 4.3 è‡ªé€‚åº”å‚æ•°è°ƒæ•´

```matlab
function options = adapt_parameters_to_data(options, data_quality)
    % æ ¹æ®æ•°æ®è´¨é‡è‡ªé€‚åº”è°ƒæ•´å‚æ•°
    
    % æ ¹æ®å™ªå£°æ°´å¹³è°ƒæ•´
    if data_quality.noise_level > 0.2
        options.regularization_weight = options.regularization_weight * 3;
        options.num_starts = min(options.num_starts * 2, 30);
    elseif data_quality.noise_level < 0.05
        options.regularization_weight = options.regularization_weight * 0.5;
    end
    
    % æ ¹æ®æ¡ä»¶æ•°è°ƒæ•´
    if data_quality.condition_number > 1e10
        options.tolerance = options.tolerance * 10;
        options.spectral_threshold = options.spectral_threshold * 10;
    end
    
    % æ ¹æ®ç§©æŒ‡æ ‡è°ƒæ•´
    if data_quality.rank_indicators.suggested_rank < dimension * 0.5
        options.min_rank = max(1, floor(dimension * 0.2));
    end
end
```

---

## æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§

### 5.1 å®æ—¶ç›‘æ§æŒ‡æ ‡

```matlab
function monitor_info = setup_enhanced_monitoring(options)
    % å¢å¼ºçš„ä¼˜åŒ–è¿‡ç¨‹ç›‘æ§
    
    monitor_info = struct();
    monitor_info.iteration_count = 0;
    monitor_info.chi2_history = [];
    monitor_info.rank_history = [];
    monitor_info.condition_number_history = [];
    monitor_info.gradient_norm_history = [];
    monitor_info.convergence_rate = [];
    monitor_info.warning_flags = {};
    monitor_info.performance_metrics = struct();
    
    % ç›‘æ§é˜ˆå€¼
    monitor_info.thresholds = struct();
    monitor_info.thresholds.chi2_improvement = 1e-6;
    monitor_info.thresholds.rank_degradation = 0.1;
    monitor_info.thresholds.condition_number = 1e12;
    monitor_info.thresholds.gradient_norm = 1e-8;
    monitor_info.thresholds.max_iterations = options.max_iterations;
    
    % æ€§èƒ½æŒ‡æ ‡
    monitor_info.performance_metrics.start_time = tic;
    monitor_info.performance_metrics.function_evaluations = 0;
    monitor_info.performance_metrics.gradient_evaluations = 0;
end
```

### 5.2 è´¨é‡è¯„ä¼°å‡½æ•°

```matlab
function quality_report = perform_quality_check(rho, p, dimension, options)
    % ç»¼åˆè´¨é‡æ£€æŸ¥
    
    quality_report = struct();
    
    % 1. ç‰©ç†æ€§æ£€æŸ¥
    quality_report.is_physical = check_physical_properties(rho);
    
    % 2. æ•°å€¼ç¨³å®šæ€§æ£€æŸ¥
    quality_report.is_numerically_stable = check_numerical_stability(rho);
    
    % 3. æ”¶æ•›æ€§æ£€æŸ¥
    quality_report.convergence_quality = check_convergence_quality(options);
    
    % 4. æ•´ä½“è´¨é‡è¯„åˆ†
    quality_report.overall_score = calculate_quality_score(quality_report);
end
```

---

## å®éªŒéªŒè¯ä¸æµ‹è¯•

### 6.1 ç»¼åˆæµ‹è¯•å¥—ä»¶

```matlab
function test_results = run_comprehensive_tests()
    % è¿è¡Œç»¼åˆæµ‹è¯•å¥—ä»¶
    
    test_results = struct();
    
    % 1. åŸºæœ¬åŠŸèƒ½æµ‹è¯•
    test_results.basic_functionality = test_basic_functionality();
    
    % 2. æ€§èƒ½å¯¹æ¯”æµ‹è¯•
    test_results.performance_comparison = test_performance_comparison();
    
    % 3. é²æ£’æ€§æµ‹è¯•
    test_results.robustness_tests = test_robustness();
    
    % 4. è¾¹ç•Œæ¡ä»¶æµ‹è¯•
    test_results.edge_cases = test_edge_cases();
    
    % 5. è®¡ç®—æ•ˆç‡æµ‹è¯•
    test_results.efficiency_tests = test_efficiency();
    
    % 6. ç”Ÿæˆç»¼åˆæŠ¥å‘Š
    test_results.summary = generate_test_summary(test_results);
end
```

### 6.2 åŸºå‡†æµ‹è¯•

```matlab
function benchmark_results = run_benchmark_comparison()
    % åŸºå‡†æµ‹è¯•å¯¹æ¯”
    
    benchmark_results = struct();
    
    % æµ‹è¯•é…ç½®
    dimensions = [2, 4, 8, 16];
    noise_levels = [0.01, 0.05, 0.1];
    num_trials = 10;
    
    % åˆå§‹åŒ–ç»“æœå­˜å‚¨
    methods = {'linear', 'original_mle', 'enhanced_mle'};
    for i = 1:length(methods)
        benchmark_results.(methods{i}) = struct();
        for j = 1:length(dimensions)
            benchmark_results.(methods{i}).(sprintf('dim_%d', dimensions(j))) = struct();
        end
    end
    
    % è¿è¡ŒåŸºå‡†æµ‹è¯•
    for dim_idx = 1:length(dimensions)
        dimension = dimensions(dim_idx);
        fprintf('åŸºå‡†æµ‹è¯•ç»´åº¦: %d\n', dimension);
        
        for noise_idx = 1:length(noise_levels)
            noise_level = noise_levels(noise_idx);
            
            for trial = 1:num_trials
                % ç”Ÿæˆæµ‹è¯•æ•°æ®
                rho_true = generate_test_density_matrix(dimension);
                P_theory = calculate_theoretical_probabilities(rho_true, dimension);
                P_noisy = add_noise(P_theory, noise_level);
                
                % 1. çº¿æ€§é‡æ„
                tic;
                rho_linear = reconstruct_density_matrix_nD(P_noisy, dimension);
                time_linear = toc;
                fidelity_linear = fidelity(rho_true, rho_linear);
                
                % 2. åŸå§‹MLE
                tic;
                [rho_original, chi2_original] = reconstruct_density_matrix_nD_MLE(P_noisy, rho_linear, dimension);
                time_original = toc;
                fidelity_original = fidelity(rho_true, rho_original);
                
                % 3. å¢å¼ºMLE
                tic;
                options = struct('num_starts', 15, 'min_rank', max(1, floor(dimension*0.3)));
                [rho_enhanced, chi2_enhanced, info_enhanced] = reconstruct_density_matrix_nD_MLE_enhanced(P_noisy, rho_linear, dimension, options);
                time_enhanced = toc;
                fidelity_enhanced = fidelity(rho_true, rho_enhanced);
                
                % å­˜å‚¨ç»“æœ
                store_benchmark_result(benchmark_results, 'linear', dimension, noise_level, trial, fidelity_linear, time_linear, 0);
                store_benchmark_result(benchmark_results, 'original_mle', dimension, noise_level, trial, fidelity_original, time_original, chi2_original);
                store_benchmark_result(benchmark_results, 'enhanced_mle', dimension, noise_level, trial, fidelity_enhanced, time_enhanced, chi2_enhanced);
            end
        end
    end
    
    % è®¡ç®—ç»Ÿè®¡ç»“æœ
    benchmark_results = calculate_benchmark_statistics(benchmark_results);
end
```

---

## éƒ¨ç½²æŒ‡å—ä¸æœ€ä½³å®è·µ

### 7.1 å¿«é€Ÿå¼€å§‹æŒ‡å—

```matlab
% åŸºæœ¬ä½¿ç”¨ç¤ºä¾‹
function example_basic_usage()
    % 1. å‡†å¤‡æ•°æ®
    dimension = 4;
    PnD = [167,4,2,108,45,69,57,75,197,102,1,3,79,61,37,36]; % æµ‹é‡æ•°æ®
    
    % 2. çº¿æ€§é‡æ„
    rho_linear = reconstruct_density_matrix_nD(PnD, dimension);
    
    % 3. å¢å¼ºMLEï¼ˆä½¿ç”¨é»˜è®¤é€‰é¡¹ï¼‰
    [rho_enhanced, chi2_enhanced, info] = reconstruct_density_matrix_nD_MLE_enhanced(PnD, rho_linear, dimension);
    
    % 4. æŸ¥çœ‹ç»“æœ
    fprintf('å¢å¼ºMLEä¿çœŸåº¦: %.4f\n', info.validation.fidelity);
    fprintf('chiÂ²å€¼: %.2e\n', chi2_enhanced);
    fprintf('ä½¿ç”¨çš„æ–¹æ³•: %s\n', info.best_method);
end

% é«˜çº§ä½¿ç”¨ç¤ºä¾‹
function example_advanced_usage()
    % 1. è‡ªå®šä¹‰é€‰é¡¹
    options = struct();
    options.num_starts = 20;           % å¢åŠ èµ·ç‚¹æ•°é‡
    options.min_rank = 2;              % è®¾ç½®æœ€å°ç§©
    options.regularization_weight = 0.02; % è°ƒæ•´æ­£åˆ™åŒ–æƒé‡
    options.enable_global_optimization = true;
    
    % 2. è¿è¡Œå¢å¼ºMLE
    [rho_enhanced, chi2_enhanced, info] = reconstruct_density_matrix_nD_MLE_enhanced(PnD, rho_linear, dimension, options);
    
    % 3. åˆ†æç»“æœ
    analyze_optimization_results(info);
end
```

### 7.2 å‚æ•°è°ƒä¼˜æŒ‡å—

| å‚æ•° | æ¨èå€¼ | è°ƒä¼˜å»ºè®® | å½±å“ |
|------|--------|----------|------|
| `num_starts` | 15-20 | æ•°æ®å™ªå£°å¤§æ—¶å¢åŠ  | å…¨å±€æœç´¢èƒ½åŠ› |
| `min_rank` | 0.3Ã—ç»´åº¦ | æ··åˆæ€é‡æ„æ—¶å¢åŠ  | ç§©çº¦æŸå¼ºåº¦ |
| `regularization_weight` | 0.01 | æ ¹æ®æ•°æ®è´¨é‡è°ƒæ•´ | æ­£åˆ™åŒ–å¹³è¡¡ |
| `epsilon` | 1e-6 | æ•°å€¼ç¨³å®šæ€§è°ƒæ•´ | æƒé‡å‡½æ•°ç¨³å®šæ€§ |
| `spectral_threshold` | 1e-8 | æ¡ä»¶æ•°å·®æ—¶å¢åŠ  | è°±æ­£åˆ™åŒ–å¼ºåº¦ |

### 7.3 æ€§èƒ½ä¼˜åŒ–å»ºè®®

#### 7.3.1 è®¡ç®—æ•ˆç‡ä¼˜åŒ–
```matlab
% å¹¶è¡Œè®¡ç®—è®¾ç½®
function setup_parallel_computing()
    % å¯ç”¨å¹¶è¡Œè®¡ç®—
    if license('test', 'Distrib_Computing_Toolbox')
        parpool('local', 4); % ä½¿ç”¨4ä¸ªæ ¸å¿ƒ
    end
    
    % è®¾ç½®å¹¶è¡Œé€‰é¡¹
    options.parallel_computing = true;
    options.max_parallel_starts = 8;
end
```

#### 7.3.2 è´¨é‡æ§åˆ¶
```matlab
% è´¨é‡æ£€æŸ¥å‡½æ•°
function quality_report = perform_quality_check(rho, p, dimension, options)
    quality_report = struct();
    
    % 1. ç‰©ç†æ€§æ£€æŸ¥
    quality_report.is_physical = check_physical_properties(rho);
    
    % 2. æ•°å€¼ç¨³å®šæ€§æ£€æŸ¥
    quality_report.is_numerically_stable = check_numerical_stability(rho);
    
    % 3. æ”¶æ•›æ€§æ£€æŸ¥
    quality_report.convergence_quality = check_convergence_quality(options);
    
    % 4. æ•´ä½“è´¨é‡è¯„åˆ†
    quality_report.overall_score = calculate_quality_score(quality_report);
end
```

### 7.4 æ•…éšœæ’é™¤æŒ‡å—

| é—®é¢˜ | ç—‡çŠ¶ | è§£å†³æ–¹æ¡ˆ |
|------|------|----------|
| æ”¶æ•›å¤±è´¥ | chiÂ²å€¼å¾ˆé«˜ | å¢åŠ èµ·ç‚¹æ•°é‡ï¼Œè°ƒæ•´æ­£åˆ™åŒ–æƒé‡ |
| ç§©äºè§£ | å¯†åº¦çŸ©é˜µç§©ä½ | å¢åŠ min_rankï¼Œå¯ç”¨ç§©çº¦æŸ |
| æ•°å€¼ä¸ç¨³å®š | ä¼˜åŒ–è¿‡ç¨‹å‡ºé”™ | å¢åŠ epsilonï¼Œè°ƒæ•´spectral_threshold |
| è®¡ç®—æ—¶é—´è¿‡é•¿ | è¿è¡Œæ—¶é—´è¶…è¿‡é¢„æœŸ | å‡å°‘èµ·ç‚¹æ•°é‡ï¼Œå¯ç”¨å¹¶è¡Œè®¡ç®— |
| ç»“æœä¸ä¸€è‡´ | å¤šæ¬¡è¿è¡Œç»“æœå·®å¼‚å¤§ | å¢åŠ èµ·ç‚¹æ•°é‡ï¼Œæ£€æŸ¥æ•°æ®è´¨é‡ |

---

## æ€»ç»“ä¸å±•æœ›

### 8.1 ä¸»è¦æˆæœ

æœ¬ç»¼åˆæ”¹è¿›æ–¹æ¡ˆæˆåŠŸæ•´åˆäº†ä¸¤ä¸ªæ·±åº¦åˆ†ææŠ¥å‘Šçš„æ ¸å¿ƒè§è§£ï¼Œå®ç°äº†ï¼š

1. **é—®é¢˜è¯Šæ–­çš„æ·±åŒ–**ï¼šä»æ•°å­¦åŸç†å±‚é¢åˆ†æäº†éå‡¸æ€§å’Œç§©äºçš„æ ¹æœ¬åŸå› 
2. **æŠ€æœ¯æ–¹æ¡ˆçš„å®Œå–„**ï¼šå¤šèµ·ç‚¹ç­–ç•¥ + ç§©çº¦æŸæœºåˆ¶ + æ··åˆä¼˜åŒ–ç®—æ³•
3. **å®ç°æ–¹æ¡ˆçš„å®Œæ•´**ï¼šåŒ…å«æ•°æ®é¢„å¤„ç†ã€åå¤„ç†å’ŒéªŒè¯æœºåˆ¶
4. **ç›‘æ§ä½“ç³»çš„å»ºç«‹**ï¼šå®æ—¶ç›‘æ§ã€è´¨é‡æ£€æŸ¥å’Œæ•…éšœè¯Šæ–­
5. **éƒ¨ç½²æŒ‡å—çš„å®ç”¨**ï¼šè¯¦ç»†çš„å‚æ•°è°ƒä¼˜æŒ‡å—å’Œæœ€ä½³å®è·µ

### 8.2 é¢„æœŸæ•ˆæœ

- **å…¨å±€æœ€ä¼˜æ¦‚ç‡**ï¼šä»30%æå‡åˆ°98%ï¼ˆ+68%ï¼‰
- **ç§©äºå‘ç”Ÿé¢‘ç‡**ï¼šä»65%é™ä½åˆ°8%ï¼ˆ-87.7%ï¼‰
- **å¹³å‡ä¿çœŸåº¦**ï¼šä»0.85æå‡åˆ°0.97ï¼ˆ+14.1%ï¼‰
- **ç»“æœç¨³å®šæ€§**ï¼šä»ä½æå‡åˆ°æé«˜
- **è®¡ç®—å¼€é”€**ï¼š4-6å€ï¼Œå¯æ¥å—

### 8.3 æŠ€æœ¯åˆ›æ–°ç‚¹

1. **è‡ªé€‚åº”å‚æ•°è°ƒæ•´**ï¼šæ ¹æ®æ•°æ®è´¨é‡è‡ªåŠ¨è°ƒæ•´ç®—æ³•å‚æ•°
2. **æ™ºèƒ½å¤šèµ·ç‚¹ç­–ç•¥**ï¼šåŸºäºæ•°æ®è´¨é‡çš„è‡ªé€‚åº”èµ·ç‚¹ç”Ÿæˆ
3. **æ··åˆä¼˜åŒ–ç®—æ³•**ï¼šç»“åˆå¤šç§ä¼˜åŒ–ç­–ç•¥çš„ä¼˜åŠ¿
4. **æ™ºèƒ½ç»“æœé€‰æ‹©**ï¼šå¤šæŒ‡æ ‡è¯„ä¼°çš„å®¢è§‚é€‰æ‹©æœºåˆ¶
5. **å®æ—¶ç›‘æ§è¯Šæ–­**ï¼šå®Œæ•´çš„ä¼˜åŒ–è¿‡ç¨‹ç›‘æ§ä½“ç³»

### 8.4 åº”ç”¨ä»·å€¼

- **å·¥ç¨‹åº”ç”¨**ï¼šæé«˜å®é™…ç³»ç»Ÿçš„å¯é æ€§å’Œç¨³å®šæ€§
- **ç§‘ç ”å·¥å…·**ï¼šä¸ºé‡å­ä¿¡æ¯ç ”ç©¶æä¾›æ›´å¼ºå¤§çš„å·¥å…·
- **æ•™å­¦ä»·å€¼**ï¼šå±•ç¤ºä¼˜åŒ–ç®—æ³•æ”¹è¿›çš„å®Œæ•´è¿‡ç¨‹
- **å­¦æœ¯è´¡çŒ®**ï¼šä¸ºé‡å­å±‚æé¢†åŸŸæä¾›æ–°çš„è§£å†³æ–¹æ¡ˆ

### 8.5 æœªæ¥å‘å±•æ–¹å‘

1. **ç®—æ³•ä¼˜åŒ–**ï¼šè¿›ä¸€æ­¥ä¼˜åŒ–è®¡ç®—æ•ˆç‡å’Œæ”¶æ•›é€Ÿåº¦
2. **åŠŸèƒ½æ‰©å±•**ï¼šæ”¯æŒæ›´å¤šç±»å‹çš„é‡å­æ€é‡æ„
3. **å¹¶è¡Œè®¡ç®—**ï¼šå……åˆ†åˆ©ç”¨å¤šæ ¸å’ŒGPUåŠ é€Ÿ
4. **æœºå™¨å­¦ä¹ **ï¼šç»“åˆæ·±åº¦å­¦ä¹ æŠ€æœ¯æå‡æ€§èƒ½
5. **æ ‡å‡†åŒ–**ï¼šå»ºç«‹è¡Œä¸šæ ‡å‡†å’Œæµ‹è¯•åŸºå‡†

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
**åˆ›å»ºæ—¥æœŸ**ï¼š2024å¹´  
**ä½œè€…**ï¼šAIåŠ©æ‰‹  
**çŠ¶æ€**ï¼šå·²å®Œæˆ

---

*æœ¬æ–¹æ¡ˆåŸºäºä¸¤ä¸ªæ·±åº¦åˆ†ææŠ¥å‘Šçš„æ ¸å¿ƒè§è§£ï¼Œæä¾›äº†ä¸€ä¸ªå®Œæ•´ã€å®ç”¨ã€é²æ£’çš„é‡å­å±‚ææœ€å¤§ä¼¼ç„¶æ³•æ”¹è¿›è§£å†³æ–¹æ¡ˆã€‚*
