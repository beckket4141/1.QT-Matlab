# å¢å¼ºç‰ˆæ··åˆæœ€å¤§ä¼¼ç„¶ä¼°è®¡ (Enhanced HMLE) ä½¿ç”¨è¯´æ˜

## ğŸ“‹ æ¦‚è¿°

å¢å¼ºç‰ˆæ··åˆæœ€å¤§ä¼¼ç„¶ä¼°è®¡ (Enhanced Hybrid Maximum Likelihood Estimation, E-HMLE) æ˜¯å¯¹ä¼ ç»Ÿé‡å­æ€å±‚ææœ€å¤§ä¼¼ç„¶ä¼°è®¡æ–¹æ³•çš„å…¨é¢æ”¹è¿›ã€‚è¯¥æ–¹æ³•åœ¨ä¼ ç»ŸHMLEçš„åŸºç¡€ä¸Šï¼Œå¼•å…¥äº†å¤šä¿¡æ¯èåˆã€è‡ªé€‚åº”å‚æ•°è°ƒæ•´ã€å¤šèµ·ç‚¹æ··åˆä¼˜åŒ–ã€æ™ºèƒ½ç»“æœé€‰æ‹©ç­‰å…ˆè¿›æŠ€æœ¯ã€‚

## ğŸš€ ä¸»è¦ç‰¹æ€§

### 1. å¤šä¿¡æ¯èåˆçš„å…ˆéªŒåˆ†æ
- **çº¿æ€§é‡æ„åˆ†æ**ï¼šåˆ†æçº¿æ€§é‡æ„ç»“æœçš„ç§©å’Œç½®ä¿¡åº¦
- **æ¦‚ç‡åˆ†å¸ƒåˆ†æ**ï¼šé€šè¿‡æµ‹é‡æ¦‚ç‡çš„åˆ†å¸ƒç‰¹å¾æ¨æ–­é‡å­æ€ç§©
- **ç»Ÿè®¡æµ‹è¯•åˆ†æ**ï¼šä½¿ç”¨ç»Ÿè®¡æ–¹æ³•ä¼°è®¡é‡å­æ€ç§©
- **ä¿¡æ¯èåˆ**ï¼šåŠ æƒèåˆå¤šç§ä¿¡æ¯æºï¼Œæé«˜ç§©ä¼°è®¡çš„å‡†ç¡®æ€§

### 2. è‡ªé€‚åº”å‚æ•°è°ƒæ•´
- **æ•°æ®è´¨é‡è¯„ä¼°**ï¼šè¯„ä¼°æµ‹é‡æ•°æ®çš„å™ªå£°æ°´å¹³ã€æ¡ä»¶æ•°å’Œç†µ
- **åŠ¨æ€å‚æ•°è°ƒæ•´**ï¼šæ ¹æ®æ•°æ®è´¨é‡å’Œå…ˆéªŒä¿¡æ¯è°ƒæ•´ç®—æ³•å‚æ•°
- **æ™ºèƒ½èµ„æºé…ç½®**ï¼šä¼˜åŒ–è®¡ç®—èµ„æºåˆ†é…

### 3. å¤šèµ·ç‚¹æ··åˆä¼˜åŒ–
- **çº¿æ€§é‡æ„èµ·ç‚¹**ï¼šä½¿ç”¨ä¼ ç»ŸHMLEçš„æ ¸å¿ƒæ–¹æ³•
- **éšæœºèµ·ç‚¹ä¼˜åŒ–**ï¼šé€šè¿‡å¤šä¸ªéšæœºèµ·ç‚¹é¿å…å±€éƒ¨æœ€ä¼˜
- **é—ä¼ ç®—æ³•**ï¼šå…¨å±€æœç´¢é¿å…å±€éƒ¨æœ€ä¼˜
- **æ¨¡æ‹Ÿé€€ç«**ï¼šå¯é€‰çš„å…¨å±€ä¼˜åŒ–æ–¹æ³•

### 4. æ™ºèƒ½ç»“æœé€‰æ‹©
- **å¤šæŒ‡æ ‡è¯„ä¼°**ï¼šè€ƒè™‘å¡æ–¹å€¼ã€ç‰©ç†æœ‰æ•ˆæ€§ã€ç§©ä¸€è‡´æ€§ã€æ•°å€¼ç¨³å®šæ€§
- **ç»¼åˆè¯„åˆ†**ï¼šåŠ æƒç»¼åˆå¤šä¸ªæŒ‡æ ‡è¿›è¡Œå®¢è§‚é€‰æ‹©
- **é¿å…å•ä¸€æŒ‡æ ‡**ï¼šä¸å•çº¯ä¾èµ–å¡æ–¹å€¼æœ€å°

### 5. è‡ªé€‚åº”ç§©çº¦æŸ
- **çº¯æ€æ£€æµ‹**ï¼šæ™ºèƒ½è¯†åˆ«çº¯æ€å¹¶åº”ç”¨ç›¸åº”çº¦æŸ
- **æ··æ€å¤„ç†**ï¼šæ ¹æ®æ£€æµ‹åˆ°çš„ç§©åº”ç”¨é€‚å½“çº¦æŸ
- **çµæ´»ç­–ç•¥**ï¼šæ ¹æ®ç½®ä¿¡åº¦é€‰æ‹©çº¦æŸç­–ç•¥

## ğŸ“– ä½¿ç”¨æ–¹æ³•

### åŸºæœ¬è°ƒç”¨

```matlab
% åŸºæœ¬è°ƒç”¨
[rho_opt, final_chi2, optimization_info] = reconstruct_density_matrix_nD_MLE_enhanced(...
    PnD, rho_r, dimension);

% å¸¦é€‰é¡¹çš„è°ƒç”¨
options = struct();
options.verbose = true;
options.enable_simulated_annealing = true;
options.num_random_starts = 15;

[rho_opt, final_chi2, optimization_info] = reconstruct_density_matrix_nD_MLE_enhanced(...
    PnD, rho_r, dimension, options);
```

### è¾“å…¥å‚æ•°

- `PnD`: æµ‹é‡æ¦‚ç‡å‘é‡ (dimension^2 x 1)
- `rho_r`: çº¿æ€§é‡æ„çš„åˆå§‹å¯†åº¦çŸ©é˜µ (dimension x dimension)
- `dimension`: é‡å­æ€ç»´åº¦
- `options`: ä¼˜åŒ–é€‰é¡¹ç»“æ„ä½“ï¼ˆå¯é€‰ï¼‰

### è¾“å‡ºå‚æ•°

- `rho_opt`: ä¼˜åŒ–åçš„å¯†åº¦çŸ©é˜µ
- `final_chi2`: æœ€ç»ˆå¡æ–¹å€¼
- `optimization_info`: ä¼˜åŒ–è¿‡ç¨‹è¯¦ç»†ä¿¡æ¯

## âš™ï¸ é€‰é¡¹é…ç½®

### åŸºæœ¬é€‰é¡¹

```matlab
options = struct();
options.verbose = true;                    % æ˜¯å¦æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
options.max_iterations = 1000;            % æœ€å¤§è¿­ä»£æ¬¡æ•°
options.tolerance = 1e-6;                 % æ”¶æ•›å®¹å·®
options.num_random_starts = 10;           % éšæœºèµ·ç‚¹æ•°é‡
options.ga_generations = 50;              % é—ä¼ ç®—æ³•ä»£æ•°
options.ga_population_size = 20;          % é—ä¼ ç®—æ³•ç§ç¾¤å¤§å°
options.enable_simulated_annealing = false; % æ˜¯å¦å¯ç”¨æ¨¡æ‹Ÿé€€ç«
options.rank_constraint_strategy = 'adaptive'; % ç§©çº¦æŸç­–ç•¥
options.physical_tolerance = 1e-10;       % ç‰©ç†å®¹å·®
```

### é«˜çº§é€‰é¡¹

```matlab
% ç§©çº¦æŸç›¸å…³
options.min_rank = 1;                     % æœ€å°ç§©
options.max_rank = dimension;             % æœ€å¤§ç§©
options.chi2_threshold = 1e-4;            % å¡æ–¹é˜ˆå€¼

% è‡ªé€‚åº”å‚æ•°è°ƒæ•´
options.adaptive_parameters = true;       % å¯ç”¨è‡ªé€‚åº”å‚æ•°è°ƒæ•´
options.quality_threshold = 0.7;          % æ•°æ®è´¨é‡é˜ˆå€¼
```

## ğŸ“Š è¾“å‡ºä¿¡æ¯è§£è¯»

### optimization_info ç»“æ„ä½“

```matlab
optimization_info.data_quality          % æ•°æ®è´¨é‡ä¿¡æ¯
optimization_info.prior_info           % å…ˆéªŒåˆ†æä¿¡æ¯
optimization_info.all_results          % æ‰€æœ‰ä¼˜åŒ–ç»“æœ
optimization_info.selection_info       % ç»“æœé€‰æ‹©ä¿¡æ¯
optimization_info.postprocess_info     % åå¤„ç†ä¿¡æ¯
optimization_info.final_rank          % æœ€ç»ˆç§©
optimization_info.final_purity        % æœ€ç»ˆçº¯åº¦
optimization_info.final_fidelity      % æœ€ç»ˆä¿çœŸåº¦
```

### å…ˆéªŒåˆ†æä¿¡æ¯

```matlab
prior_info.linear_rank                 % çº¿æ€§é‡æ„æ£€æµ‹çš„ç§©
prior_info.linear_confidence          % çº¿æ€§é‡æ„ç½®ä¿¡åº¦
prior_info.prob_rank                  % æ¦‚ç‡åˆ†å¸ƒæ£€æµ‹çš„ç§©
prior_info.prob_confidence            % æ¦‚ç‡åˆ†å¸ƒç½®ä¿¡åº¦
prior_info.stat_rank                  % ç»Ÿè®¡æµ‹è¯•æ£€æµ‹çš„ç§©
prior_info.stat_confidence            % ç»Ÿè®¡æµ‹è¯•ç½®ä¿¡åº¦
prior_info.detected_rank              % èåˆåæ£€æµ‹çš„ç§©
prior_info.confidence                 % èåˆåç½®ä¿¡åº¦
prior_info.rank_strategy              % ç§©çº¦æŸç­–ç•¥
```

## ğŸ”§ ä½¿ç”¨ç¤ºä¾‹

### ç¤ºä¾‹1ï¼šçº¯æ€é‡æ„

```matlab
% ç”Ÿæˆçº¯æ€æµ‹è¯•æ•°æ®
dimension = 2;
psi_pure = [1; 0];
rho_pure = psi_pure * psi_pure';

% ç”Ÿæˆæµ‹é‡æ¦‚ç‡
[~, mu] = generate_projectors_and_operators(dimension);
PnD = zeros(dimension^2, 1);
for k = 1:dimension^2
    PnD(k) = real(trace(rho_pure * mu{k}));
end

% æ·»åŠ å™ªå£°
PnD = PnD + 0.05 * randn(size(PnD));
PnD = max(PnD, 0);
PnD = PnD / sum(PnD);

% çº¿æ€§é‡æ„
rho_linear = reconstruct_density_matrix_nD(PnD, dimension);

% å¢å¼ºç‰ˆHMLEé‡æ„
options = struct();
options.verbose = true;
[rho_opt, chi2_opt, info] = reconstruct_density_matrix_nD_MLE_enhanced(...
    PnD, rho_linear, dimension, options);

% æ˜¾ç¤ºç»“æœ
fprintf('æœ€ç»ˆç§©: %d, çº¯åº¦: %.6f, ä¿çœŸåº¦: %.6f\n', ...
        info.final_rank, info.final_purity, info.final_fidelity);
```

### ç¤ºä¾‹2ï¼šæ··æ€é‡æ„

```matlab
% ç”Ÿæˆæ··æ€æµ‹è¯•æ•°æ®
dimension = 2;
rho_mixed = 0.7 * [1;0]*[1;0]' + 0.3 * eye(dimension)/dimension;

% ç”Ÿæˆæµ‹é‡æ¦‚ç‡å¹¶æ·»åŠ å™ªå£°
[~, mu] = generate_projectors_and_operators(dimension);
PnD = zeros(dimension^2, 1);
for k = 1:dimension^2
    PnD(k) = real(trace(rho_mixed * mu{k}));
end
PnD = PnD + 0.1 * randn(size(PnD));
PnD = max(PnD, 0);
PnD = PnD / sum(PnD);

% çº¿æ€§é‡æ„
rho_linear = reconstruct_density_matrix_nD(PnD, dimension);

% å¢å¼ºç‰ˆHMLEé‡æ„
options = struct();
options.verbose = true;
options.enable_simulated_annealing = true;
[rho_opt, chi2_opt, info] = reconstruct_density_matrix_nD_MLE_enhanced(...
    PnD, rho_linear, dimension, options);

% æ˜¾ç¤ºç»“æœ
fprintf('æ£€æµ‹ç­–ç•¥: %s, æœ€ç»ˆç§©: %d\n', ...
        info.prior_info.rank_strategy, info.final_rank);
```

## ğŸ¯ æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. å‚æ•°è°ƒä¼˜

- **é«˜è´¨é‡æ•°æ®**ï¼šå‡å°‘éšæœºèµ·ç‚¹æ•°å’Œé—ä¼ ç®—æ³•ä»£æ•°
- **ä½è´¨é‡æ•°æ®**ï¼šå¢åŠ éšæœºèµ·ç‚¹æ•°å’Œè¿­ä»£æ¬¡æ•°
- **çº¯æ€æ£€æµ‹**ï¼šå¯ç”¨çº¯æ€çº¦æŸç­–ç•¥
- **æ··æ€æ£€æµ‹**ï¼šä½¿ç”¨çµæ´»çº¦æŸç­–ç•¥

### 2. è®¡ç®—èµ„æºç®¡ç†

```matlab
% å¿«é€Ÿæ¨¡å¼ï¼ˆé€‚åˆå®æ—¶åº”ç”¨ï¼‰
options.num_random_starts = 5;
options.ga_generations = 30;
options.enable_simulated_annealing = false;

% ç²¾ç¡®æ¨¡å¼ï¼ˆé€‚åˆç¦»çº¿åˆ†æï¼‰
options.num_random_starts = 20;
options.ga_generations = 100;
options.enable_simulated_annealing = true;
```

### 3. å†…å­˜ä¼˜åŒ–

- å¯¹äºå¤§ç»´åº¦ç³»ç»Ÿï¼Œè€ƒè™‘å‡å°‘ç§ç¾¤å¤§å°
- ä½¿ç”¨å¹¶è¡Œè®¡ç®—åŠ é€Ÿå¤šèµ·ç‚¹ä¼˜åŒ–
- å®šæœŸæ¸…ç†ä¸­é—´ç»“æœ

## âš ï¸ æ³¨æ„äº‹é¡¹

### 1. ä¾èµ–å‡½æ•°

ç¡®ä¿ä»¥ä¸‹å‡½æ•°å¯ç”¨ï¼š
- `reconstruct_density_matrix_nD.m`
- `FindInitialT.m`
- `likelihood_function.m`
- `construct_density_matrix.m`
- `makephysical.m`
- `generate_projectors_and_operators.m`

### 2. æ•°å€¼ç¨³å®šæ€§

- å¯¹äºç—…æ€æ•°æ®ï¼Œå¢åŠ ç‰©ç†å®¹å·®
- ç›‘æ§æ¡ä»¶æ•°ï¼Œé¿å…æ•°å€¼ä¸ç¨³å®š
- ä½¿ç”¨é€‚å½“çš„æ­£åˆ™åŒ–å‚æ•°

### 3. æ”¶æ•›æ€§

- å¦‚æœä¼˜åŒ–ä¸æ”¶æ•›ï¼Œå°è¯•å¢åŠ è¿­ä»£æ¬¡æ•°
- æ£€æŸ¥æ•°æ®è´¨é‡å’Œå…ˆéªŒä¿¡æ¯
- è€ƒè™‘è°ƒæ•´ä¼˜åŒ–ç®—æ³•å‚æ•°

## ğŸ” æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

1. **ä¼˜åŒ–ä¸æ”¶æ•›**
   - å¢åŠ  `max_iterations`
   - è°ƒæ•´ `tolerance`
   - æ£€æŸ¥æ•°æ®è´¨é‡

2. **ç»“æœä¸ç†æƒ³**
   - å¢åŠ  `num_random_starts`
   - å¯ç”¨æ¨¡æ‹Ÿé€€ç«
   - æ£€æŸ¥å…ˆéªŒåˆ†æç»“æœ

3. **å†…å­˜ä¸è¶³**
   - å‡å°‘ `ga_population_size`
   - å‡å°‘ `num_random_starts`
   - ä½¿ç”¨æ›´å°çš„ç»´åº¦

### è°ƒè¯•æ¨¡å¼

```matlab
options.verbose = true;  % å¯ç”¨è¯¦ç»†è¾“å‡º
options.debug = true;    % å¯ç”¨è°ƒè¯•æ¨¡å¼ï¼ˆå¦‚æœæ”¯æŒï¼‰
```

## ğŸ“ˆ æ€§èƒ½æŒ‡æ ‡

### è¯„ä¼°æŒ‡æ ‡

- **å¡æ–¹å€¼**ï¼šè¡¡é‡æ‹Ÿåˆè´¨é‡
- **ä¿çœŸåº¦**ï¼šè¡¡é‡ä¸çœŸå®æ€çš„ç›¸ä¼¼æ€§
- **çº¯åº¦**ï¼šè¡¡é‡é‡å­æ€çš„çº¯åº¦
- **ç§©**ï¼šè¡¡é‡é‡å­æ€çš„æ··åˆç¨‹åº¦
- **ç‰©ç†æœ‰æ•ˆæ€§**ï¼šç¡®ä¿ç»“æœç¬¦åˆç‰©ç†çº¦æŸ

### åŸºå‡†æµ‹è¯•

å»ºè®®åœ¨æ ‡å‡†æµ‹è¯•é›†ä¸Šè¯„ä¼°æ€§èƒ½ï¼š
- çº¯æ€é‡æ„ç²¾åº¦
- æ··æ€é‡æ„ç²¾åº¦
- å™ªå£°é²æ£’æ€§
- è®¡ç®—æ•ˆç‡

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. James, D. F. V., et al. "Measurement of qubits." Physical Review A 64.5 (2001): 052312.
2. Hradil, ZdenÄ›k. "Quantum-state estimation." Physical Review A 55.3 (1997): R1561.
3. Å˜ehÃ¡Äek, Jaroslav, et al. "Iterative algorithm for reconstruction of entangled states." Physical Review A 60.1 (1999): 473.
4. Altepeter, Joseph B., et al. "Ancilla-assisted quantum process tomography." Physical Review Letters 90.19 (2003): 193601.

## ğŸ“ æŠ€æœ¯æ”¯æŒ

å¦‚æœ‰é—®é¢˜æˆ–å»ºè®®ï¼Œè¯·è”ç³»å¼€å‘å›¢é˜Ÿæˆ–æŸ¥çœ‹ç›¸å…³æ–‡æ¡£ã€‚

---

**ç‰ˆæœ¬**: v2.0 Enhanced HMLE  
**æ›´æ–°æ—¥æœŸ**: 2024  
**å…¼å®¹æ€§**: MATLAB R2018b+
